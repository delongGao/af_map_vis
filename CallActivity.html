<html>
<head>
<!-- <script src="d3/d3.min.js" charset="utf-8"></script> -->
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<title>
Animated Line Graph for a Month - Migration Vs Non-Migrated
</title>
</head>
<style type="text/css">

svg {
  font-family: "Helvetica Neue", Helvetica;
}

.line {
  fill: none;
}

.legend rect {
    fill:white;
    stroke:black;
    opacity:0.8;
}


</style>
<body>
<H1>Line Graph showing Average Transactions made by Migrated and Non-migrated Users</H1>
</body>

<!-- <script type="text/javascript" src="d3/d3.min.js"></script>-->
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script>
/*************

*************/
// Space between the the left side screen and the start of the line graph.

function sleepFor( sleepDuration ){
        var now = new Date().getTime();
        while(new Date().getTime() < now + sleepDuration){ /* do nothing */ }
    }



var t = 1;

var weekdays = ["Mon","Tues","Wed","Thurs","Fri","Sat","Sun"];
var formatDay = function(d) {
    return weekdays[d % 7] + "day";
}

//**************************************************** Constants ****************************************************
var migText = "MIGRATED"
var nonmigText = "NON-MIGRATED"

//**************************************************** Variables ****************************************************
var TotalWidth=600;
var TotalHeight=800;

var margin = 20;
var m = [margin, margin+20, margin, margin+40],// +60 to make sure that full text of Non-migrated is visible.
    w = TotalWidth - m[1] - m[3],  // 1 -> left , 3 -> right
    h = TotalHeight - m[0] - m[2];  // 0 -> top 2 -> bottom

var activityData,x,y,duration = 0,delay = 100;
var linEle,linCircle,overCircle ;
var color = d3.scale.ordinal().range(["green", "red"]);

var svg = d3.select("body").append("svg")
    .attr("width", w + m[1] + m[3])
    .attr("height",h + m[0] + m[2])
    .append("g")
    .attr("transform", "translate(" + m[3] + "," + m[0] + ")"); // translate to (20,20) so that everything starts runs with that point as origin

//var gradient = svg.append("svg:defs")
//        .append("svg:linearGradient")
//        .attr("id", "gradient")
//        .attr("x1", "0%")
//        .attr("y1", "0%")
//        .attr("x2", "10%")
//        .attr("y2", "10%")
//        .attr("spreadMethod", "pad");
//
//// Define the gradient colors
//gradient.append("svg:stop")
//        .attr("offset", "0%")
//        .attr("stop-color", "#ffffff")
//        .attr("stop-opacity", 1);
//
//gradient.append("svg:stop")
//        .attr("offset", "50%")
//        .attr("stop-color", "#ffffff")
//        .attr("stop-opacity", 1);

var line = d3.svg.line()
    .interpolate("monotone")
    .x(function(d) { return x(d.date); })// d.Day
    .y(function(d) { return y(d.actValue); }); // d.Count

//d3.csv("2012-01-Kabul-CallActivityGraph.txt", function(data) {
d3.json("2012-01-Kabul-CallActivityGraph.json", function(data) {
  var parseDate = d3.time.format("%Y%m%d").parse;
  activityData = d3.nest().key(function(d) { return d.type; }).entries(data); //.entries(stocks = data);

  activityData.forEach(function(s) {
    s.values.forEach(function(d) { d.date = parseDate(d.date); d.actValue = d.actValue; });
    s.maxPrice = d3.max(s.values, function(d) { return d.actValue; }); // console.log(s);
  });

// .attr("x1",w-502).attr("y1",180).attr("x2",w-50).attr("y2",180)

  svg.append("text").attr("class", "x label").attr("text-anchor", "end").attr("x", w-200).attr("y",150)
            .text("Days of the Month").attr("fill","black");


  svg.append("text").attr("class", "y label").attr("text-anchor", "end").attr("x", 20).attr("dy", -20)
          .attr("transform", "rotate(-90)").text("Number of Calls/Day").attr("fill","black");


  svg.append("line").attr("x1",w-500).attr("y1",-30).attr("x2",w-500).attr("y2",120).attr("stroke-width", 3).attr("stroke", "black");

  svg.append("line").attr("x1",w-502).attr("y1",120).attr("x2",w-50).attr("y2",120).attr("stroke-width", 3).attr("stroke", "black");


  var g = svg.selectAll("g").data(activityData).enter().append("g").attr("class", "symbol");


  setTimeout(lines, duration); // Duration = 1000

});


function lines() {
  x = d3.time.scale().range([0, w - 60]); console.log("X Range:  " + (w - 60))
  y = d3.scale.linear().range([h / 4 - 20, 0]); console.log("Y Range: " + (h / 4 - 20))

  var xMin = d3.min(activityData, function(d) { return d.values[0].date; });
  var xMax = d3.max(activityData, function(d) { return d.values[d.values.length - 1].date; })

  x.domain([ xMin,xMax]);

  var g = svg.selectAll(".symbol").attr("transform", function(d) {return "translate(0," + 0 + ")"; });  // ( h / 4 - 30) plots it higher

  var xAxis = d3.svg.axis().scale(x).orient("bottom").tickSize(-h).tickFormat(formatDay);; //.tickSubdivide(true);
  var yAxis = d3.svg.axis().scale(y).ticks(30).orient("right"); // ticks has 30 - Needs to change wrt to the length of activityData

  //var textEle = svg.append("text").attr("x", 12).attr("y", 10).text("TEST").attr("fill","white");

    g.each(function(d) {
    var e = d3.select(this); //console.log("this:");console.log(this);

    e.append("path").attr("class", "line");

    e.append("circle").attr("r", 4)
       .style("fill", function(d) { if((d.key.toString()) == nonmigText) return d3.rgb("green"); else return d3.rgb("red")})
       .style("stroke", "#fff")
       .style("stroke-width", "1px");

// // Display your types(Migrated/Non-Migrated) besides the circle.
    e.append("text") .attr("x", 12).attr("y", 10).attr("fill",function(d) { if((d.key.toString()) == nonmigText) return d3.rgb("green"); else return d3.rgb("red")}).text("");

   linEle = e.append("line").attr("stroke-width", 3).attr("stroke", "blue").style("stroke-opacity",0.7);
   // http://stackoverflow.com/questions/20837147/draw-a-d3-circle-with-gradient-colours
   linCircle = e.append("circle");

   //console.log("Scaled:" + x(10));console.log("    Scaled:" + x(w-350));

     // Y-axis Line
   //e.append("line").attr("x1",w-500).attr("y1",0).attr("x2",w-500).attr("y2",180).attr("stroke-width", 3).attr("stroke", "black");

    // X-axis line
  // e.append("line").attr("x1",w-502).attr("y1",180).attr("x2",w-50).attr("y2",180).attr("stroke-width", 3).attr("stroke", "black");


  });

  function draw(k) {
    g.each(function(d) {
      var e = d3.select(this);
      //console.log(this);
      y.domain([0, d.maxPrice]);  // y.domain([0, function(d) { return d.maxPrice ; } ]); Didn't work

      e.select("path").attr("stroke",function(d) {
          if((d.key.toString()) == nonmigText)
              return d3.rgb("green");
          else
              return d3.rgb("red")})
        .attr("stroke-width", 2)
        .attr("d", function(d) {return line(d.values.slice(0,k+1)); });


// Animating the circle - If this is commented the circle stays at one place.

      e.selectAll("circle, text").data(function(d) { dummy = [d.values[k], d.values[k]]; //console.log(d.values[k]);
       return [d.values[k], d.values[k]]; })
          .attr("transform", function(d) {
                  //console.log("(x(d.date),y(d.price)) ==> "  + "translate(" + x(d.date) + "," + y(d.actValue) + ")" );
                  return "translate(" + x(d.date) + "," + y(d.actValue) + ")"; });
/*

          linEle.attr("transform", function(d) { return "translate(" + x(d.date) + "," + y(d.actValue) + ")"; })
                .attr("x1",x(d.values[k].date))
                .attr("y1", h-460)
                .attr("x2",x(d.values[k].date))
                .attr("y2", h-340)
                .attr("stroke-width", 3).attr("stroke", "white")
                .style("stroke-opacity",0.7);

       linCircle.attr("transform", function(d) { return "translate(" + x(d.date) + "," + y(d.actValue) + ")"; }).attr("cx",x(d.values[k].date)).attr("cy",h-460).attr("r",5)
               //.style("fill","white")
               .attr('fill', 'url(#gradient)')
               .style("stroke", "#fff")
               .style("stroke-width", "1px")
               */

        //overCircle.attr("transform", function(d) { return "translate(" + x(d.date) + "," + y(d.actValue) + ")"; }).attr("cx",x(d.values[k].date)).attr("cy",h-460).attr("r",10);

        //console.log("Data values");console.log(x(d.values[k].date));
    });
  }

  var k = 1, n = activityData[0].values.length;
  console.log("n Timer: " + n);
  d3.timer(function() {
      //http://stackoverflow.com/posts/17936490/revisions
      sleepFor(200);
      draw(k);
      //setTimeout(draw(k),duration);
      //setInterval(draw(k),10000);
    if ((k += 2) >= n - 1) {
      draw(n - 1);
      //setTimeout(draw(n-1),duration)
      //setTimeout(horizons, 500);
      return true;
    }

  });
}

</script>
</html>


